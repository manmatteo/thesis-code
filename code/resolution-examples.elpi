module resolution-examples.
% accumulate control.
accum_sig kernel/lkf-formulas.
accumulate client/cforms, client/lkf-polarize.
accumulate kernel/lkf-kernel.
accumulate fpc/mimic-lkf-fpc.
accumulate fpc/resolution-checkers.

% type a, b, c, d cform.
% kind map type.
% type map list (pair index cform) -> map.
type run prop.
type resolve (list (pair index cform)) -> cform -> cert -> prop.
type r1, r2, a, b, c cform.
atomic r1 & atomic r2 & atomic a & atomic b & atomic c.
polarize_neg r1 & polarize_neg r2 & polarize_neg a & polarize_neg b & polarize_neg c.
type problem  string -> cform -> cert -> (list (pair index cform)) -> o.
type problem_old  string -> form -> cert -> (list (pair index cform)) -> o.
% type map list (pair index cform) -> map.

problem "bprop1"
  (or (and (neg r1) (neg r2))
  (or (and (r1)     (neg r2))
  (r2)))
	(rsteps [resolv (idx 1) (idx 2) (idx 4), resolv (idx 3) (idx 4) (idx 0)]
  (istate [1, 2, 3]))
  ([
   pr (idx 1) (or r1 r2),
   pr (idx 2) (or (neg r1) r2),
   pr (idx 3) (neg r2),
   pr (idx 4) (r2),
   pr (idx 0) ff]).

problem "bprop2"
	(or a (neg a))
  (rsteps [resolv (idx 1) (idx 2) (idx 0)] (istate [1,2]))
  ([
   pr (idx 1) (neg a),
   pr (idx 2) (a),
   pr (idx 0) ff]).

problem "bprop3"
  (or (and a b)
  (or (and (neg a) b)
  (or (and a (neg b))
  (and (neg a) (neg b)))))
 	(rsteps [resolv (idx 1) (idx 2) (idx 5), resolv (idx 3) (idx 4) (idx 6), resolv (idx 5) (idx 6) (idx 0)] (istate [1,2,3,4]))
  ([
   pr (idx 1) (or (neg a) (neg b)),
   pr (idx 2) (or a (neg b)),
   pr (idx 3) (or (neg a) b),
   pr (idx 4) (or a b),
   pr (idx 5) (neg b),
   pr (idx 6) (b),
   pr (idx 0) ff]).

problem "bprop4"
  (or (and a (and b (neg c)))
  (or (and (neg a) b)
  (or (and a (and (neg b) (neg c)))
  (or (and (neg a) (neg b))
  c))))
 (rsteps [resolv (idx 1) (idx 2) (idx 6), resolv (idx 3) (idx 4) (idx 7), resolv (idx 6) (idx 7) (idx 8), resolv (idx 5) (idx 8) (idx 0)]
 (istate [1,2,3,4,5]))
 ([
   pr (idx 1) (or (neg a) (or (neg b) c)),
   pr (idx 2) (or a (neg b)),
   pr (idx 3) (or (neg a) (or b c)),
   pr (idx 4) (or a b),
   pr (idx 5) (neg c),
   pr (idx 6) (or (neg b) c),
   pr (idx 7) (or b b),
   pr (idx 8) (c),
   pr (idx 0) ff]).

main :-
  problem Name F Cert (Map),
  print "Running on problem " Name ":\n",
  resolve Map F Cert.
type polar cform -> form -> prop.
polar X Y :- polarize_res X Y, !.
resolve [] F Cert :-
  polar F PolF,
  print "Polarized as" PolF,
  if (lkf_entry Cert PolF)
     (print "Success\n==============================================\n")
     (print "Fail\n", halt), fail.
resolve [(pr I C) | R] F Cert :-
  mapsto I C => resolve R F Cert.